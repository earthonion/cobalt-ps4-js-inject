#pragma once
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

// Orbis / GoldHEN helpers you already have
#include "plugin_common.h"
#include "patch.h"
#include "hde/hde64.h"

// ---- Configuration ---------------------------------------------------------
#ifndef MH_MAX_PROLOGUE
#define MH_MAX_PROLOGUE 32     // enough to cover our 14B abs jmp
#endif

// ---- Types -----------------------------------------------------------------
typedef enum { MH_MODE_NONE=0, MH_MODE_THUNK=1, MH_MODE_WRAPPER=2 } mh_mode_t;

typedef struct mh_hook_t {
    uint64_t target_addr;
    void*    user_impl;       // your C callback
    void*    user_thunk;      // optional thunk entry (NULL => wrapper mode)
    void*    thunk_slot;      // address of the thunk's slot symbol (only for thunk mode)
    void*    tramp_mem;       // allocated trampoline
    size_t   tramp_size;
    void*    orig_fn;         // points to trampoline (call this to reach original)
    size_t   stolen_len;
    uint8_t  original[MH_MAX_PROLOGUE];
    int      installed;
    mh_mode_t mode;
} mh_hook_t;

// ---- API -------------------------------------------------------------------
#ifdef __cplusplus
extern "C" {
#endif
/**
 * Compute a safe instruction boundary near `addr` that covers at least min_size.
 * Uses HDE64; returns the total size (0 on failure).
 */
size_t mh_calc_prologue_len(uintptr_t addr, size_t min_size);

/**
 * Install a hook:
 *   - `hook->target_addr` must be set before calling
 *   - `hook->user_thunk`  is your asm bridge (generated by macro below)
 *   - `hook->user_impl`   is your C callback called by the thunk
 *
 * On success:
 *   - `hook->orig_fn` points at the trampoline (cast to your typedef)
 *   - `hook->installed` = true
 */
int mh_install(mh_hook_t *hook);

/**
 * Remove a previously installed hook (restores original bytes, unmaps tramp).
 */
int mh_remove(mh_hook_t *hook);

// ---- Utils -----------------------------------------------------------------
void mh_log(const char *fmt, ...);
void mh_bind_thunk_slot(void **slot_addr, void *trampoline);

#ifdef __cplusplus
}
#endif

// ---- Thunk generator --------------------------------------------------------
/**
 * Define a per-hook thunk + storage symbol (RIP-addressable) in one shot.
 *
 * Example:
 *   // 1) Define your typed original and callback signature
 *   typedef long (*playback_t)(long, char*, int, int);
 *   long my_callback(long a, char *cmd, int b, int sz);
 *
 *   // 2) Create a hook object and a thunk bound to it
 *   static mh_hook_t g_pb_hook = {0};
 *   MH_DEFINE_THUNK(pb, my_callback)
 *
 *   // 3) When installing:
 *   g_pb_hook.user_impl = (void*)my_callback;
 *   g_pb_hook.user_thunk = (void*)MH_THUNK_ENTRY(pb);
 *   // after mh_install(&g_pb_hook), cast:
 *   playback_t original = (playback_t)g_pb_hook.orig_fn;
 * 
 */
#define MH_STR1(x) #x
#define MH_STR(x)  MH_STR1(x)

#define MH_THUNK_LABEL(name)      __mh_thunk_##name
#define MH_TRAMP_SLOT(name)       __mh_tramp_slot_##name
#define MH_THUNK_ENTRY(name)      MH_THUNK_LABEL(name)

#ifdef __GNUC__
#define MH_DEFINE_THUNK(name, cb_fn)                           \
    __attribute__((used)) void *MH_TRAMP_SLOT(name) = 0;               \
    __attribute__((naked)) void MH_THUNK_LABEL(name)(void) {           \
        __asm__ volatile(                                              \
            /* Prologue + spill volatile integer regs to stack */               \
            "push %rbp\n"                                                       \
            "mov  %rsp, %rbp\n"                                                 \
            /* Reserve 0x60 bytes: 8 regs * 8 bytes = 64, plus 0x10 pad to align */ \
            "sub  $0x60, %rsp\n"                                                \
            "mov  %rdi, -0x08(%rbp)\n"  /* save rdi */                          \
            "mov  %rsi, -0x10(%rbp)\n"  /* save rsi */                          \
            "mov  %rdx, -0x18(%rbp)\n"  /* save rdx */                          \
            "mov  %rcx, -0x20(%rbp)\n"  /* save rcx */                          \
            "mov  %r8,  -0x28(%rbp)\n"  /* save r8  */                          \
            "mov  %r9,  -0x30(%rbp)\n"  /* save r9  */                          \
            "mov  %r10, -0x38(%rbp)\n"  /* save r10 */                          \
            "mov  %r11, -0x40(%rbp)\n"  /* save r11 */                          \
            /* If you expect FP args, also save XMM0â€“XMM5 here with movdqu. */  \
                                                                                \
            /* Set up args for callback (they're already in regs, but safe) */  \
            "mov  -0x08(%rbp), %rdi\n"                                          \
            "mov  -0x10(%rbp), %rsi\n"                                          \
            "mov  -0x18(%rbp), %rdx\n"                                          \
            "mov  -0x20(%rbp), %rcx\n"                                          \
            /*"mov  -0x28(%rbp), %r8\n"   /* pass r8 (5th arg) */                 \
            /*"mov  -0x30(%rbp), %r9\n"   /* pass r9 (6th arg) */                 \
                                                                                \
            /* Keep stack 16B aligned at call site: rbp-based frame is aligned */\
            "call " MH_STR(cb_fn) "\n"                                          \
                                                                                \
            /* Restore volatile regs exactly as caller passed them */           \
            "mov  -0x08(%rbp), %rdi\n"                                          \
            "mov  -0x10(%rbp), %rsi\n"                                          \
            "mov  -0x18(%rbp), %rdx\n"                                          \
            "mov  -0x20(%rbp), %rcx\n"                                          \
            "mov  -0x28(%rbp), %r8\n"                                           \
            "mov  -0x30(%rbp), %r9\n"                                           \
            "mov  -0x38(%rbp), %r10\n"                                          \
            "mov  -0x40(%rbp), %r11\n"                                          \
                                                                                \
            "leave\n"                                                           \
            "lea " MH_STR(MH_TRAMP_SLOT(name)) "(%rip), %rax\n"         \
             "jmp *(%rax)\n"                    \
        );                                                             \
    }
// ---- Extended thunk for functions with many arguments (up to 14) ----------
// Use this macro when your function has more than 6 arguments
#define MH_DEFINE_THUNK_LARGE(name, cb_fn)                            \
    __attribute__((used)) void *MH_TRAMP_SLOT(name) = 0;               \
    __attribute__((naked)) void MH_THUNK_LABEL(name)(void) {           \
        __asm__ volatile(                                              \
            /* Save frame and make space */                            \
            "push %rbp\n"                                               \
            "mov  %rsp, %rbp\n"                                        \
            "sub  $0x80, %rsp\n"  /* Space for saved regs + locals */  \
                                                                        \
            /* Save all argument registers */                          \
            "mov  %rdi, -0x08(%rbp)\n"  /* arg1 */                     \
            "mov  %rsi, -0x10(%rbp)\n"  /* arg2 */                     \
            "mov  %rdx, -0x18(%rbp)\n"  /* arg3 */                     \
            "mov  %rcx, -0x20(%rbp)\n"  /* arg4 */                     \
            "mov  %r8,  -0x28(%rbp)\n"  /* arg5 */                     \
            "mov  %r9,  -0x30(%rbp)\n"  /* arg6 */                     \
            "mov  %r10, -0x38(%rbp)\n"  /* r10 preserved */            \
            "mov  %r11, -0x40(%rbp)\n"  /* r11 preserved */            \
                                                                        \
            /* Stack args start at rbp+16 (after ret addr + saved rbp) */ \
            /* We need to copy them for the callback */                \
            /* Copy args 7-14 from original stack to new stack */      \
                                                                        \
            /* Push stack arguments in reverse order (14 to 7) */      \
            "mov  0x48(%rbp), %rax\n"  /* arg 14 */                    \
            "push %rax\n"                                               \
            "mov  0x40(%rbp), %rax\n"  /* arg 13 */                    \
            "push %rax\n"                                               \
            "mov  0x38(%rbp), %rax\n"  /* arg 12 */                    \
            "push %rax\n"                                               \
            "mov  0x30(%rbp), %rax\n"  /* arg 11 */                    \
            "push %rax\n"                                               \
            "mov  0x28(%rbp), %rax\n"  /* arg 10 */                    \
            "push %rax\n"                                               \
            "mov  0x20(%rbp), %rax\n"  /* arg 9 */                     \
            "push %rax\n"                                               \
            "mov  0x18(%rbp), %rax\n"  /* arg 8 */                     \
            "push %rax\n"                                               \
            "mov  0x10(%rbp), %rax\n"  /* arg 7 */                     \
            "push %rax\n"                                               \
                                                                        \
            /* Restore register args for callback */                   \
            "mov  -0x08(%rbp), %rdi\n"                                 \
            "mov  -0x10(%rbp), %rsi\n"                                 \
            "mov  -0x18(%rbp), %rdx\n"                                 \
            "mov  -0x20(%rbp), %rcx\n"                                 \
            "mov  -0x28(%rbp), %r8\n"                                  \
            "mov  -0x30(%rbp), %r9\n"                                  \
                                                                        \
            /* Call callback - it will see all 14 args */              \
            "call " MH_STR(cb_fn) "\n"                                 \
                                                                        \
            /* Clean up pushed stack args (8 * 8 bytes) */             \
            "add  $0x40, %rsp\n"                                        \
                                                                        \
            /* Restore all registers for original call */              \
            "mov  -0x08(%rbp), %rdi\n"                                 \
            "mov  -0x10(%rbp), %rsi\n"                                 \
            "mov  -0x18(%rbp), %rdx\n"                                 \
            "mov  -0x20(%rbp), %rcx\n"                                 \
            "mov  -0x28(%rbp), %r8\n"                                  \
            "mov  -0x30(%rbp), %r9\n"                                  \
            "mov  -0x38(%rbp), %r10\n"                                 \
            "mov  -0x40(%rbp), %r11\n"                                 \
                                                                        \
            /* Return to original via trampoline */                    \
            "leave\n"                                                   \
            "lea " MH_STR(MH_TRAMP_SLOT(name)) "(%rip), %rax\n"         \
             "jmp *(%rax)\n"                                            \
        );                                                             \
    }

#else
#error "This thunk macro expects GCC/clang style inline asm."
#endif
